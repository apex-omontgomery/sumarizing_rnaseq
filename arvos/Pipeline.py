#!/usr/bin/python
"""
Run DESeq and EdgeR
"""

import os,sys,re,csv
import numpy as np
import pandas as pd
import sklearn
import subprocess


class Pipeline():
    """
    A generic class
    """

    def __init__(self):
        """
        Constructor

        """



    ###################
    # General Methods #
    ###################
    def run_subprocess(self,cmd):
        proc = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stdin=subprocess.PIPE)
        try:
            outs, errs = proc.communicate(timeout=22000)
        except TimeoutExpired:
            proc.kill()
            outs, errs = proc.communicate()

    ######################################
    # Methods for the Predictive portion #
    ######################################
    # input: X_file is a count matrix that has been transformed by DESeq2
    #        y_file is a target file generated by the user
    def generate_data(X_file, y_file):
        from sklearn.model_selection import train_test_split
        # samples are rows, genes are columns
        X = pd.read_csv("examples/pieris/results/deseq-samples.csv", index_col=0).transpose()
        y = np.loadtxt("examples/pieris/data/targets.csv", delimiter=",", dtype = int)
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)
        return X_train, X_test, y_train, y_test


    #######################################
    # Methods for the Associative portion #
    #######################################
    def create_filtered(self, countsPath):
        if not os.path.exists(countsPath):
            raise Exception("Cannot find counts path")

        filteredCountsPath = re.sub("\.csv","-filtered.csv",countsPath)
        fid1 = open(countsPath,'r')
        fid2 = open(filteredCountsPath,'w')
        reader = csv.reader(fid1)
        writer = csv.writer(fid2)
        header = next(reader)
        writer.writerow(header)

        for linja in reader:
            if np.array([float(i) for i in linja[1:]]).sum() > 1:
                writer.writerow(linja)
        fid1.close()
        fid2.close()
        return filteredCountsPath

    def run_deseq(self,countsPath,outFile):
        cmd = "Rscript runDESeq.R %s %s"%(countsPath,outFile)
        print("running...\n%s"%cmd)
        self.run_subprocess(cmd)

    # input:
    # (self, header array from count file, path (without file name))
    # output:
    # saved file for user to do something with.
    def two_group(self, head, c_Path):
        #is outputting a csv and having them manipulate good?
        with open(c_Path+ 'vartypes.csv', 'w',newline='\n') as f:
            writer = csv.writer(f)
            writer.writerow(head)
            writer.writerow(['variable']+ ['0 or 1']*(len(head)-1))


if __name__ == "__main__":

    ## specify the locations
    homeDir = os.path.join("..")
    readsDir = os.path.join(homeDir, "reads")

    parentDir = os.path.join(homeDir,"examples", "pieris")
    countsPath = os.path.join(parentDir,"data", "est_counts.csv")
    outDirectory = os.path.join(parentDir, "results")
    outFile = os.path.join(outDirectory, "deseq.csv")

    # check if results directory exists, if !exist create one
    if not os.path.exists(outDirectory):
        os.mkdir(outDirectory)


    associative = Associative()
    filteredCountsPath = associative.create_filtered(countsPath)
    associative.run_deseq(filteredCountsPath,outFile)
